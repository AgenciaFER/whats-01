# Plano de ImplementaÃ§Ã£o do Painel WhatsApp com whatsmeow

## Legenda
- ðŸŸ¢ ConcluÃ­do
- ðŸŸ¡ Em implementaÃ§Ã£o
- ðŸ”´ Pendente

## 1. PreparaÃ§Ã£o do Ambiente ðŸŸ¢

### 1.1 ConfiguraÃ§Ã£o do Projeto ðŸŸ¢
```bash
mkdir whatsapp-panel
cd whatsapp-panel
go mod init github.com/seu-usuario/whatsapp-panel
```

### 1.2 InstalaÃ§Ã£o de Todas as DependÃªncias ðŸŸ¢
```bash
# Frameworks e bibliotecas principais
go get github.com/gin-gonic/gin
go get go.mau.fi/whatsmeow
go get github.com/skip2/go-qrcode
go get github.com/mattn/go-sqlite3

# Outras dependÃªncias
go get github.com/joho/godotenv
go get github.com/google/uuid
go get github.com/gin-contrib/cors
go get github.com/gin-contrib/sessions
go get github.com/gin-contrib/sessions/cookie
```

## 2. Estrutura do Projeto ðŸŸ¢

Criar a seguinte estrutura de diretÃ³rios:

```
whatsapp-panel/
â”œâ”€â”€ cmd/
â”‚   â””â”€â”€ server/
â”‚       â””â”€â”€ main.go
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â””â”€â”€ config.go
â”‚   â”œâ”€â”€ handlers/
â”‚   â”‚   â”œâ”€â”€ auth.go
â”‚   â”‚   â”œâ”€â”€ session.go
â”‚   â”‚   â””â”€â”€ whatsapp.go
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ session.go
â”‚   â”‚   â””â”€â”€ stats.go
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â””â”€â”€ whatsapp/
â”‚   â”‚       â”œâ”€â”€ client.go
â”‚   â”‚       â”œâ”€â”€ handler.go
â”‚   â”‚       â””â”€â”€ session.go
â”‚   â””â”€â”€ storage/
â”‚       â”œâ”€â”€ database.go
â”‚       â””â”€â”€ sqlite.go
â”œâ”€â”€ web/
â”‚   â”œâ”€â”€ assets/
â”‚   â”‚   â”œâ”€â”€ css/
â”‚   â”‚   â”‚   â””â”€â”€ style.css
â”‚   â”‚   â””â”€â”€ js/
â”‚   â”‚       â””â”€â”€ app.js
â”‚   â””â”€â”€ templates/
â”‚       â”œâ”€â”€ index.html
â”‚       â”œâ”€â”€ qrcode.html
â”‚       â””â”€â”€ partials/
â”‚           â”œâ”€â”€ header.html
â”‚           â”œâ”€â”€ footer.html
â”‚           â””â”€â”€ session_card.html
â”œâ”€â”€ go.mod
â”œâ”€â”€ go.sum
â””â”€â”€ README.md
```

## 3. ImplementaÃ§Ã£o da Camada de Dados ðŸŸ¢

### 3.1 ConfiguraÃ§Ã£o (internal/config/config.go)
```go
package config

import (
	"os"
	"path/filepath"

	"github.com/joho/godotenv"
)

type Config struct {
	Port         string
	DatabasePath string
	StoreDir     string
}

func LoadConfig() (*Config, error) {
	// Carregar variÃ¡veis de ambiente do arquivo .env se existir
	godotenv.Load()

	// Configurar diretÃ³rio para armazenamento
	storeDir := os.Getenv("STORE_DIR")
	if storeDir == "" {
		userHomeDir, err := os.UserHomeDir()
		if err != nil {
			return nil, err
		}
		storeDir = filepath.Join(userHomeDir, ".whatsapp-panel")
	}

	// Criar diretÃ³rio se nÃ£o existir
	if _, err := os.Stat(storeDir); os.IsNotExist(err) {
		if err := os.MkdirAll(storeDir, 0755); err != nil {
			return nil, err
		}
	}

	// Configurar caminho do banco de dados
	dbPath := os.Getenv("DB_PATH")
	if dbPath == "" {
		dbPath = filepath.Join(storeDir, "whatsapp.db")
	}

	// Obter porta do servidor
	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}

	return &Config{
		Port:         port,
		DatabasePath: dbPath,
		StoreDir:     storeDir,
	}, nil
}
```

### 3.2 Banco de Dados (internal/storage/sqlite.go)
```go
package storage

import (
	"database/sql"
	"fmt"
	"time"

	_ "github.com/mattn/go-sqlite3"
)

type Database struct {
	db *sql.DB
}

// FunÃ§Ã£o para criar uma nova instÃ¢ncia do banco de dados
func NewDatabase(dbPath string) (*Database, error) {
	db, err := sql.Open("sqlite3", dbPath)
	if err != nil {
		return nil, fmt.Errorf("erro ao abrir banco de dados: %v", err)
	}

	// Verificar conexÃ£o
	if err := db.Ping(); err != nil {
		return nil, fmt.Errorf("erro ao conectar ao banco de dados: %v", err)
	}

	// Criar tabelas necessÃ¡rias
	if err := createTables(db); err != nil {
		return nil, fmt.Errorf("erro ao criar tabelas: %v", err)
	}

	return &Database{db: db}, nil
}

// Criar todas as tabelas necessÃ¡rias
func createTables(db *sql.DB) error {
	// Tabela para sessÃµes WhatsApp
	_, err := db.Exec(`
		CREATE TABLE IF NOT EXISTS whatsapp_sessions (
			id TEXT PRIMARY KEY,
			name TEXT NOT NULL,
			jid TEXT NOT NULL,
			phone_number TEXT,
			connected_at TIMESTAMP NOT NULL,
			last_active TIMESTAMP NOT NULL,
			status TEXT NOT NULL
		)
	`)
	if err != nil {
		return err
	}

	// Tabela para estatÃ­sticas das sessÃµes
	_, err = db.Exec(`
		CREATE TABLE IF NOT EXISTS session_stats (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			session_id TEXT NOT NULL,
			contacts INTEGER NOT NULL DEFAULT 0,
			groups INTEGER NOT NULL DEFAULT 0,
			conversations INTEGER NOT NULL DEFAULT 0,
			updated_at TIMESTAMP NOT NULL,
			FOREIGN KEY (session_id) REFERENCES whatsapp_sessions (id) ON DELETE CASCADE
		)
	`)
	if err != nil {
		return err
	}

	return nil
}

// Fechar conexÃ£o com o banco de dados
func (d *Database) Close() error {
	return d.db.Close()
}

// SaveSession armazena informaÃ§Ãµes da sessÃ£o no banco de dados
func (d *Database) SaveSession(id, name, jid, phoneNumber string) error {
	now := time.Now()
	
	_, err := d.db.Exec(
		`INSERT INTO whatsapp_sessions (id, name, jid, phone_number, connected_at, last_active, status) 
		 VALUES (?, ?, ?, ?, ?, ?, ?)
		 ON CONFLICT(id) DO UPDATE SET 
		    name = excluded.name,
		    jid = excluded.jid,
		    phone_number = excluded.phone_number,
		    last_active = excluded.last_active,
		    status = excluded.status`,
		id, name, jid, phoneNumber, now, now, "connected",
	)
	
	return err
}

// UpdateSessionStats atualiza as estatÃ­sticas de uma sessÃ£o
func (d *Database) UpdateSessionStats(sessionID string, contacts, groups, conversations int) error {
	now := time.Now()
	
	_, err := d.db.Exec(
		`INSERT INTO session_stats (session_id, contacts, groups, conversations, updated_at)
		 VALUES (?, ?, ?, ?, ?)
		 ON CONFLICT(session_id) DO UPDATE SET
		   contacts = excluded.contacts,
		   groups = excluded.groups,
		   conversations = excluded.conversations,
		   updated_at = excluded.updated_at`,
		sessionID, contacts, groups, conversations, now,
	)
	
	return err
}

// GetAllSessions retorna todas as sessÃµes ativas
func (d *Database) GetAllSessions() ([]map[string]interface{}, error) {
	rows, err := d.db.Query(`
		SELECT s.id, s.name, s.jid, s.phone_number, s.connected_at, s.last_active, s.status,
		       COALESCE(st.contacts, 0) as contacts,
		       COALESCE(st.groups, 0) as groups,
		       COALESCE(st.conversations, 0) as conversations
		FROM whatsapp_sessions s
		LEFT JOIN session_stats st ON s.id = st.session_id
		WHERE s.status = 'connected'
		ORDER BY s.connected_at DESC
	`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	
	sessions := []map[string]interface{}{}
	
	for rows.Next() {
		var (
			id, name, jid, phoneNumber, status string
			connectedAt, lastActive            time.Time
			contacts, groups, conversations    int
		)
		
		if err := rows.Scan(&id, &name, &jid, &phoneNumber, &connectedAt, &lastActive, &status, &contacts, &groups, &conversations); err != nil {
			return nil, err
		}
		
		session := map[string]interface{}{
			"ID":          id,
			"Name":        name,
			"JID":         jid,
			"PhoneNumber": phoneNumber,
			"ConnectedAt": connectedAt.Format("02/01/2006 15:04:05"),
			"LastActive":  lastActive.Format("02/01/2006 15:04:05"),
			"Status":      status,
			"Stats": map[string]int{
				"Contacts":      contacts,
				"Groups":        groups,
				"Conversations": conversations,
			},
		}
		
		sessions = append(sessions, session)
	}
	
	return sessions, nil
}

// DeleteSession remove uma sessÃ£o do banco de dados
func (d *Database) DeleteSession(id string) error {
	_, err := d.db.Exec("DELETE FROM whatsapp_sessions WHERE id = ?", id)
	return err
}
```

### 3.3 Modelos de Dados (internal/models/session.go)
```go
package models

import (
	"time"
)

// Session representa uma sessÃ£o do WhatsApp
type Session struct {
	ID          string    `json:"id"`
	Name        string    `json:"name"`
	JID         string    `json:"jid"`
	PhoneNumber string    `json:"phone_number"`
	ConnectedAt time.Time `json:"connected_at"`
	LastActive  time.Time `json:"last_active"`
	Status      string    `json:"status"` // connected, disconnected, etc.
	Stats       Stats     `json:"stats"`
}

// SessionList Ã© uma lista de sessÃµes para facilitar o uso em templates
type SessionList []Session

// Stats contÃ©m estatÃ­sticas de uma sessÃ£o do WhatsApp
type Stats struct {
	Contacts      int `json:"contacts"`
	Groups        int `json:"groups"`
	Conversations int `json:"conversations"`
}
```

## 4. ImplementaÃ§Ã£o do ServiÃ§o WhatsApp ðŸŸ¢

### 4.1 Cliente WhatsApp (internal/services/whatsapp/client.go)
```go
package whatsapp

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"sync"
	"time"

	"github.com/google/uuid"
	"go.mau.fi/whatsmeow"
	"go.mau.fi/whatsmeow/store"
	"go.mau.fi/whatsmeow/store/sqlstore"
	waProto "go.mau.fi/whatsmeow/types/events"
	waLog "go.mau.fi/whatsmeow/util/log"

	"github.com/seu-usuario/whatsapp-panel/internal/models"
	"github.com/seu-usuario/whatsapp-panel/internal/storage"
)

// Cliente WhatsApp
type Client struct {
	WAClient     *whatsmeow.Client
	JID          string
	ID           string
	eventHandler *EventHandler
	store        *sqlstore.Container
	db           *storage.Database
	log          waLog.Logger
	qrChan       chan string
	connected    bool
	mutex        sync.Mutex
}

// Gerenciador de clientes
type Manager struct {
	clients     map[string]*Client
	storeDir    string
	db          *storage.Database
	log         waLog.Logger
	clientsLock sync.Mutex
}

// Criar novo gerenciador de clientes
func NewManager(storeDir string, db *storage.Database) *Manager {
	// Configurar logger
	logger := waLog.Stdout("whatsmeow", "INFO", true)
	
	return &Manager{
		clients:  make(map[string]*Client),
		storeDir: storeDir,
		db:       db,
		log:      logger,
	}
}

// Criar novo cliente
func (m *Manager) NewClient() (*Client, error) {
	// Gerar ID Ãºnico para o cliente
	clientID := uuid.New().String()
	
	// Configurar caminho do banco de dados para esta sessÃ£o
	dbPath := filepath.Join(m.storeDir, fmt.Sprintf("%s.db", clientID))
	
	// Criar container de armazenamento
	container, err := sqlstore.New("sqlite3", fmt.Sprintf("file:%s?_foreign_keys=on", dbPath), m.log)
	if err != nil {
		return nil, fmt.Errorf("falha ao configurar banco de dados da sessÃ£o: %v", err)
	}
	
	// Criar novo dispositivo
	deviceStore, err := container.NewDevice()
	if err != nil {
		return nil, fmt.Errorf("falha ao criar dispositivo: %v", err)
	}
	
	// Criar cliente WhatsApp
	waClient := whatsmeow.NewClient(deviceStore, m.log)
	
	// Criar handler de eventos
	eventHandler := NewEventHandler(m.db, clientID)
	
	// Adicionar handler ao cliente
	waClient.AddEventHandler(eventHandler.Handle)
	
	// Criar cliente
	client := &Client{
		WAClient:     waClient,
		ID:           clientID,
		eventHandler: eventHandler,
		store:        container,
		db:           m.db,
		log:          m.log,
		qrChan:       make(chan string),
		connected:    false,
	}
	
	// Registrar cliente no gerenciador
	m.clientsLock.Lock()
	m.clients[clientID] = client
	m.clientsLock.Unlock()
	
	return client, nil
}

// Obter cliente pelo ID
func (m *Manager) GetClient(id string) (*Client, bool) {
	m.clientsLock.Lock()
	defer m.clientsLock.Unlock()
	
	client, exists := m.clients[id]
	return client, exists
}

// Remover cliente
func (m *Manager) RemoveClient(id string) {
	m.clientsLock.Lock()
	defer m.clientsLock.Unlock()
	
	if client, exists := m.clients[id]; exists {
		client.Disconnect()
		delete(m.clients, id)
	}
}

// Conectar cliente
func (c *Client) Connect() error {
	if c.WAClient.IsConnected() {
		return nil
	}
	
	// Conectar ao WhatsApp
	err := c.WAClient.Connect()
	if err != nil {
		return fmt.Errorf("falha ao conectar ao WhatsApp: %v", err)
	}
	
	return nil
}

// Desconectar cliente
func (c *Client) Disconnect() error {
	if !c.WAClient.IsConnected() {
		return nil
	}
	
	c.WAClient.Disconnect()
	return nil
}

// Obter canal para QR Code
func (c *Client) GetQRChannel(ctx context.Context) (<-chan string, error) {
	// Verificar se cliente jÃ¡ estÃ¡ conectado
	if c.WAClient.IsConnected() {
		return nil, fmt.Errorf("cliente jÃ¡ estÃ¡ conectado")
	}
	
	// Configurar handler para QR Code
	c.mutex.Lock()
	if c.qrChan == nil {
		c.qrChan = make(chan string)
	}
	c.mutex.Unlock()
	
	// Adicionar handler temporÃ¡rio para QR Code
	qrHandler := func(evt interface{}) {
		if qrEvent, ok := evt.(*waProto.QR); ok {
			select {
			case c.qrChan <- qrEvent.Code:
				// QR Code enviado com sucesso
			case <-ctx.Done():
				// Contexto cancelado
				return
			}
		}
	}
	
	// Adicionar handler temporÃ¡rio
	removeHandler := c.WAClient.AddEventHandler(qrHandler)
	
	// Remover handler automaticamente quando o contexto for cancelado
	go func() {
		<-ctx.Done()
		removeHandler()
		
		// Fechar canal de QR Code
		c.mutex.Lock()
		if c.qrChan != nil {
			close(c.qrChan)
			c.qrChan = nil
		}
		c.mutex.Unlock()
	}()
	
	// Conectar cliente em uma goroutine
	go func() {
		err := c.Connect()
		if err != nil {
			c.log.Errorf("Falha ao conectar: %v", err)
			
			c.mutex.Lock()
			if c.qrChan != nil {
				close(c.qrChan)
				c.qrChan = nil
			}
			c.mutex.Unlock()
		}
	}()
	
	return c.qrChan, nil
}

// Obter estatÃ­sticas do cliente
func (c *Client) GetStats() (*models.Stats, error) {
	if !c.WAClient.IsConnected() {
		return nil, fmt.Errorf("cliente nÃ£o estÃ¡ conectado")
	}
	
	stats := &models.Stats{
		Contacts:      len(c.WAClient.Store.Contacts),
		Groups:        0,
		Conversations: len(c.WAClient.Store.Chats),
	}
	
	// Contar grupos
	for _, chat := range c.WAClient.Store.Chats {
		if chat.IsGroup {
			stats.Groups++
		}
	}
	
	// Atualizar estatÃ­sticas no banco de dados
	err := c.db.UpdateSessionStats(c.ID, stats.Contacts, stats.Groups, stats.Conversations)
	if err != nil {
		c.log.Warnf("Falha ao atualizar estatÃ­sticas no BD: %v", err)
	}
	
	return stats, nil
}

// Verificar se o cliente estÃ¡ conectado
func (c *Client) IsConnected() bool {
	return c.WAClient != nil && c.WAClient.IsConnected()
}

// Obter informaÃ§Ãµes do cliente
func (c *Client) GetInfo() *models.Session {
	isConnected := c.WAClient.IsConnected()
	phoneNumber := ""
	
	if isConnected {
		// Obter nÃºmero de telefone
		if c.WAClient.Store.ID != nil {
			phoneNumber = c.WAClient.Store.ID.User
		}
	}
	
	// Obter estatÃ­sticas
	stats := models.Stats{
		Contacts:      0,
		Groups:        0,
		Conversations: 0,
	}
	
	if isConnected {
		// Tentar obter estatÃ­sticas
		if s, err := c.GetStats(); err == nil {
			stats = *s
		}
	}
	
	// Criar sessÃ£o
	session := &models.Session{
		ID:          c.ID,
		JID:         c.WAClient.Store.ID.String(),
		PhoneNumber: phoneNumber,
		Name:        fmt.Sprintf("WhatsApp (%s)", phoneNumber),
		ConnectedAt: time.Now(), // Idealmente, isso seria armazenado quando o cliente se conecta
		LastActive:  time.Now(),
		Status:      "connected",
		Stats:       stats,
	}
	
	return session
}
```

### 4.2 Handler de Eventos (internal/services/whatsapp/handler.go)
```go
package whatsapp

import (
	"fmt"
	"strings"
	"time"

	"go.mau.fi/whatsmeow/types/events"

	"github.com/seu-usuario/whatsapp-panel/internal/storage"
)

// EventHandler gerencia eventos do WhatsApp
type EventHandler struct {
	db        *storage.Database
	sessionID string
}

// Criar novo handler de eventos
func NewEventHandler(db *storage.Database, sessionID string) *EventHandler {
	return &EventHandler{
		db:        db,
		sessionID: sessionID,
	}
}

// Handle processa eventos do WhatsApp
func (h *EventHandler) Handle(evt interface{}) {
	switch v := evt.(type) {
	case *events.Connected:
		// Evento disparado quando o cliente Ã© conectado ao WhatsApp
		fmt.Println("Conectado ao WhatsApp")
		
	case *events.Disconnected:
		// Evento disparado quando o cliente Ã© desconectado
		fmt.Println("Desconectado do WhatsApp:", v.Reason)
		
	case *events.LoggedOut:
		// Evento disparado quando o cliente Ã© deslogado
		fmt.Println("SessÃ£o encerrada no WhatsApp")
		
	case *events.PushName:
		// Evento disparado quando o nome Ã© atualizado
		fmt.Println("Nome atualizado:", v.Name)
		
	case *events.PairSuccess:
		// Evento disparado quando o pareamento Ã© bem-sucedido
		fmt.Printf("Pareamento bem-sucedido com dispositivo %s\n", v.ID.String())
		
	case *events.Message:
		// Evento disparado quando uma mensagem Ã© recebida
		fmt.Printf("Mensagem recebida de %s\n", v.Info.Sender.String())
		
	default:
		// Nada a fazer para outros eventos
	}
}

// UpdateSessionInfo atualiza as informaÃ§Ãµes da sessÃ£o no banco de dados
func (h *EventHandler) UpdateSessionInfo(name, jid, phoneNumber string) error {
	if h.db == nil {
		return fmt.Errorf("banco de dados nÃ£o inicializado")
	}
	
	// Salvar sessÃ£o no banco de dados
	err := h.db.SaveSession(h.sessionID, name, jid, phoneNumber)
	if err != nil {
		return fmt.Errorf("falha ao salvar sessÃ£o: %v", err)
	}
	
	return nil
}
```

## 5. ImplementaÃ§Ã£o dos Handlers HTTP ðŸŸ¢

### 5.1 Handler para SessÃµes (internal/handlers/session.go)
```go
package handlers

import (
	"context"
	"encoding/base64"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/skip2/go-qrcode"

	"github.com/seu-usuario/whatsapp-panel/internal/services/whatsapp"
	"github.com/seu-usuario/whatsapp-panel/internal/storage"
}

// SessionHandler gerencia requisiÃ§Ãµes relacionadas Ã s sessÃµes do WhatsApp
type SessionHandler struct {
	waManager *whatsapp.Manager
	db        *storage.Database
}

// Criar novo handler para sessÃµes
func NewSessionHandler(waManager *whatsapp.Manager, db *storage.Database) *SessionHandler {
	return &SessionHandler{
		waManager: waManager,
		db:        db,
	}
}

// GetSessions retorna todas as sessÃµes ativas
func (h *SessionHandler) GetSessions(c *gin.Context) {
	// Obter todas as sessÃµes do banco de dados
	sessions, err := h.db.GetAllSessions()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Falha ao obter sessÃµes: " + err.Error(),
		})
		return
	}
	
	c.HTML(http.StatusOK, "sessions.html", gin.H{
		"Sessions": sessions,
	})
}

// GetQRCode gera um QR Code para conectar ao WhatsApp
func (h *SessionHandler) GetQRCode(c *gin.Context) {
	// Criar novo cliente WhatsApp
	client, err := h.waManager.NewClient()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Falha ao criar cliente WhatsApp: " + err.Error(),
		})
		return
	}
	
	// Criar contexto com timeout de 2 minutos
	ctx, cancel := context.WithTimeout(context.Background(), 2*time.Minute)
	defer cancel()
	
	// Obter canal de QR Code
	qrChan, err := client.GetQRChannel(ctx)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Falha ao obter QR Code: " + err.Error(),
		})
		return
	}
	
	// Aguardar QR Code ou timeout
	select {
	case qrCode, ok := <-qrChan:
		if !ok {
			c.JSON(http.StatusInternalServerError, gin.H{
				"error": "Canal de QR Code fechado",
			})
			return
		}
		
		// Gerar imagem do QR Code
		qr, err := qrcode.Encode(qrCode, qrcode.Medium, 256)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"error": "Falha ao gerar imagem do QR Code: " + err.Error(),
			})
			return
		}
		
		// Converter para base64
		qrBase64 := base64.StdEncoding.EncodeToString(qr)
		
		// Renderizar template com QR Code
		c.HTML(http.StatusOK, "qrcode.html", gin.H{
			"QRCode":    qrBase64,
			"SessionID": client.ID,
		})
		
	case <-ctx.Done():
		c.JSON(http.StatusRequestTimeout, gin.H{
			"error": "Timeout ao aguardar QR Code",
		})
	}
}

// CheckConnection verifica o status da conexÃ£o de uma sessÃ£o
func (h *SessionHandler) CheckConnection(c *gin.Context) {
	sessionID := c.Query("session_id")
	if sessionID == "" {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "ID da sessÃ£o nÃ£o fornecido",
		})
		return
	}
	
	// Obter cliente pelo ID
	client, exists := h.waManager.GetClient(sessionID)
	if !exists {
		c.JSON(http.StatusNotFound, gin.H{
			"error": "SessÃ£o nÃ£o encontrada",
		})
		return
	}
	
	// Verificar se estÃ¡ conectado
	connected := client.IsConnected()
	
	// Se estiver conectado, salvar informaÃ§Ãµes da sessÃ£o
	if connected {
		info := client.GetInfo()
		
		// Salvar sessÃ£o no banco de dados
		err := h.db.SaveSession(
			info.ID,
			info.Name,
			info.JID,
			info.PhoneNumber,
		)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"error": "Falha ao salvar informaÃ§Ãµes da sessÃ£o: " + err.Error(),
			})
			return
		}
		
		// Atualizar estatÃ­sticas
		err = h.db.UpdateSessionStats(
			info.ID,
			info.Stats.Contacts,
			info.Stats.Groups,
			info.Stats.Conversations,
		)
		if err != nil {
			// Apenas log, nÃ£o falhar a requisiÃ§Ã£o
			c.Error(err)
		}
	}
	
	c.JSON(http.StatusOK, gin.H{
		"connected": connected,
	})
}

// DeleteSession remove uma sessÃ£o
func (h *SessionHandler) DeleteSession(c *gin.Context) {
	sessionID := c.Param("id")
	if sessionID == "" {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "ID da sessÃ£o nÃ£o fornecido",
		})
		return
	}
	
	// Remover cliente do gerenciador
	h.waManager.RemoveClient(sessionID)
	
	// Remover sessÃ£o do banco de dados
	err := h.db.DeleteSession(sessionID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Falha ao remover sessÃ£o: " + err.Error(),
		})
		return
	}
	
	// Recarregar lista de sessÃµes
	c.Redirect(http.StatusSeeOther, "/")
}
```

### 5.2 Handler Principal (internal/handlers/whatsapp.go)
```go
package handlers

import (
	"net/http"

	"github.com/gin-gonic/gin"

	"github.com/seu-usuario/whatsapp-panel/internal/services/whatsapp"
	"github.com/seu-usuario/whatsapp-panel/internal/storage"
)

// WhatsAppHandler gerencia requisiÃ§Ãµes relacionadas ao WhatsApp
type WhatsAppHandler struct {
	waManager *whatsapp.Manager
	db        *storage.Database
}

// Criar novo handler para WhatsApp
func NewWhatsAppHandler(waManager *whatsapp.Manager, db *storage.Database) *WhatsAppHandler {
	return &WhatsAppHandler{
		waManager: waManager,
		db:        db,
	}
}

// Index renderiza a pÃ¡gina principal
func (h *WhatsAppHandler) Index(c *gin.Context) {
	// Obter todas as sessÃµes do banco de dados
	sessions, err := h.db.GetAllSessions()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Falha ao obter sessÃµes: " + err.Error(),
		})
		return
	}
	
	c.HTML(http.StatusOK, "index.html", gin.H{
		"Sessions": sessions,
	})
}
```

## 6. ImplementaÃ§Ã£o do Servidor Principal ðŸŸ¢

### 6.1 Servidor Principal (cmd/server/main.go)
```go
package main

import (
	"fmt"
	"log"
	"net/http"
	"path/filepath"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"

	"github.com/seu-usuario/whatsapp-panel/internal/config"
	"github.com/seu-usuario/whatsapp-panel/internal/handlers"
	"github.com/seu-usuario/whatsapp-panel/internal/services/whatsapp"
	"github.com/seu-usuario/whatsapp-panel/internal/storage"
)

func main() {
	// Carregar configuraÃ§Ãµes
	cfg, err := config.LoadConfig()
	if err != nil {
		log.Fatalf("Erro ao carregar configuraÃ§Ãµes: %v", err)
	}

	// Inicializar banco de dados
	db, err := storage.NewDatabase(cfg.DatabasePath)
	if err != nil {
		log.Fatalf("Erro ao inicializar banco de dados: %v", err)
	}
	defer db.Close()

	// Inicializar gerenciador de clientes WhatsApp
	waManager := whatsapp.NewManager(cfg.StoreDir, db)

	// Inicializar handlers
	sessionHandler := handlers.NewSessionHandler(waManager, db)
	whatsappHandler := handlers.NewWhatsAppHandler(waManager, db)

	// Configurar servidor Gin
	router := gin.Default()

	// Configurar CORS
	router.Use(cors.New(cors.Config{
		AllowOrigins:     []string{"*"},
		AllowMethods:     []string{"GET", "POST", "DELETE"},
		AllowHeaders:     []string{"Origin", "Content-Type"},
		ExposeHeaders:    []string{"Content-Length"},
		AllowCredentials: true,
	}))

	// Carregar templates
	router.LoadHTMLGlob("web/templates/**/*")

	// Servir arquivos estÃ¡ticos
	router.Static("/assets", "./web/assets")

	// Definir rotas
	router.GET("/", whatsappHandler.Index)
	router.GET("/qrcode", sessionHandler.GetQRCode)
	router.GET("/sessions", sessionHandler.GetSessions)
	router.GET("/connection-status", sessionHandler.CheckConnection)
	router.DELETE("/sessions/:id", sessionHandler.DeleteSession)

	// Iniciar servidor
	addr := fmt.Sprintf(":%s", cfg.Port)
	log.Printf("Servidor iniciado em http://localhost%s", addr)
	if err := router.Run(addr); err != nil {
		log.Fatalf("Erro ao iniciar servidor: %v", err)
	}
}
```

## 7. ImplementaÃ§Ã£o do Frontend ðŸŸ¡

### 7.1 Templates HTML

#### 7.1.1 Template Principal (web/templates/index.html)
```html
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Painel WhatsApp</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <script src="https://unpkg.com/htmx.org@1.9.6"></script>
</head>
<body class="bg-gray-100 min-h-screen">
    <div class="container mx-auto px-4 py-8">
        <header class="mb-8">
            <h1 class="text-3xl font-bold text-gray-800">Painel de Controle WhatsApp</h1>
        </header>
        
        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <div class="flex justify-between items-center">
                <h2 class="text-xl font-semibold">Suas ConexÃµes</h2>
                <button 
                    hx-get="/qrcode" 
                    hx-target="#qrcodeModal" 
                    hx-swap="innerHTML"
                    class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-md flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clip-rule="evenodd" />
                    </svg>
                    Conectar WhatsApp
                </button>
            </div>
        </div>
        
        <div id="sessions" class="space-y-4">
            <!-- Aqui serÃ£o inseridos os cards de sessÃµes -->
            {{ range .Sessions }}
                {{ template "session_card.html" . }}
            {{ end }}
        </div>
        
        <!-- Modal para QR Code -->
        <div id="qrcodeModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <!-- ConteÃºdo do modal serÃ¡ carregado via HTMX -->
        </div>
    </div>
    
    <script>
        document.body.addEventListener('htmx:afterSwap', function(evt) {
            if (evt.detail.target.id === 'qrcodeModal') {
                document.getElementById('qrcodeModal').classList.remove('hidden');
            }
        });
        
        function closeModal() {
            document.getElementById('qrcodeModal').classList.add('hidden');
        }
        
        function checkSessionStatus() {
            htmx.ajax('GET', '/sessions', {target: '#sessions', swap: 'innerHTML'});
        }
        
        // Atualizar status das sessÃµes a cada 5 segundos
        setInterval(checkSessionStatus, 5000);
    </script>
</body>
</html>
```

#### 7.1.2 Partial de Card de SessÃ£o (web/templates/partials/session_card.html)
```html
<div class="bg-white rounded-lg shadow-md p-4" id="session-{{ .ID }}">
    <div class="flex items-center justify-between mb-3">
        <div class="flex items-center gap-3">
            <div class="h-12 w-12 rounded-full bg-green-500 flex items-center justify-center text-white">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
                </svg>
            </div>
            <div>
                <h3 class="font-semibold">{{ .Name }}</h3>
                <p class="text-sm text-gray-500">Conectado desde {{ .ConnectedAt }}</p>
            </div>
        </div>
        <button 
            hx-delete="/sessions/{{ .ID }}"
            hx-confirm="Tem certeza que deseja desconectar?"
            hx-target="#session-{{ .ID }}"
            hx-swap="outerHTML"
            class="text-red-500 hover:text-red-700">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" />
            </svg>
        </button>
    </div>
    
    <div class="grid grid-cols-3 gap-4 text-center">
        <div class="bg-gray-50 p-3 rounded-md">
            <div class="text-xl font-bold">{{ .Stats.Contacts }}</div>
            <div class="text-xs text-gray-500">Contatos</div>
        </div>
        <div class="bg-gray-50 p-3 rounded-md">
            <div class="text-xl font-bold">{{ .Stats.Groups }}</div>
            <div class="text-xs text-gray-500">Grupos</div>
        </div>
        <div class="bg-gray-50 p-3 rounded-md">
            <div class="text-xl font-bold">{{ .Stats.Conversations }}</div>
            <div class="text-xs text-gray-500">Conversas</div>
        </div>
    </div>
</div>
```

#### 7.1.3 Template do QR Code (web/templates/qrcode.html)
```html
<div class="bg-white rounded-lg p-6 max-w-md w-full relative">
    <button onclick="closeModal()" class="absolute top-2 right-2 text-gray-500 hover:text-gray-700">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
        </svg>
    </button>
    
    <h2 class="text-xl font-bold mb-4 text-center">Conecte seu WhatsApp</h2>
    
    <div class="text-center mb-4">
        <p class="text-sm text-gray-600 mb-2">Escaneie o cÃ³digo QR com seu WhatsApp</p>
        <div id="countdown" class="text-sm font-semibold" x-data="{ time: 60 }" x-init="setInterval(() => { if(time > 0) time--; }, 1000)">
            Expira em <span x-text="time"></span> segundos
        </div>
    </div>
    
    <div class="flex justify-center mb-4">
        <img src="data:image/png;base64,{{ .QRCode }}" alt="QR Code" class="h-64 w-64">
    </div>
    
    <div class="text-center text-sm text-gray-500">
        <p>1. Abra o WhatsApp no seu telefone</p>
        <p>2. Toque em Menu ou ConfiguraÃ§Ãµes e selecione WhatsApp Web</p>
        <p>3. Escaneie o cÃ³digo QR acima</p>
    </div>
</div>

<script>
    // Verificar status da conexÃ£o a cada segundo
    let checkConnectionInterval = setInterval(function() {
        fetch('/connection-status?session_id={{ .SessionID }}')
            .then(response => response.json())
            .then(data => {
                if (data.connected) {
                    clearInterval(checkConnectionInterval);
                    closeModal();
                    checkSessionStatus(); // Atualizar lista de sessÃµes
                }
            });
    }, 1000);
    
    // Recarregar QR Code apÃ³s 60 segundos
    setTimeout(function() {
        if (document.getElementById('qrcodeModal').classList.contains('hidden') === false) {
            htmx.ajax('GET', '/qrcode', {target: '#qrcodeModal', swap: 'innerHTML'});
        }
    }, 60000);
</script>
```

#### 7.1.4 Template de SessÃµes (web/templates/sessions.html)
```html
<!-- Partial para ser carregado via HTMX -->
{{ range .Sessions }}
    {{ template "session_card.html" . }}
{{ end }}
```

### 7.2 CSS e JavaScript

#### 7.2.1 CSS Principal (web/assets/css/style.css)
```css
/* Estilos personalizados adicionais, se necessÃ¡rio */
.pulse {
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0% {
        transform: scale(0.95);
        box-shadow: 0 0 0 0 rgba(37, 211, 102, 0.7);
    }
    
    70% {
        transform: scale(1);
        box-shadow: 0 0 0 10px rgba(37, 211, 102, 0);
    }
    
    100% {
        transform: scale(0.95);
        box-shadow: 0 0 0 0 rgba(37, 211, 102, 0);
    }
}
```

#### 7.2.2 JavaScript Principal (web/assets/js/app.js)
```javascript
// FunÃ§Ãµes auxiliares para interaÃ§Ã£o com a interface

// FunÃ§Ã£o para atualizar automaticamente o status das sessÃµes
function setupSessionStatusPolling() {
    setInterval(function() {
        if (document.getElementById('sessions')) {
            htmx.ajax('GET', '/sessions', {target: '#sessions', swap: 'innerHTML'});
        }
    }, 5000);
}

// FunÃ§Ã£o para formatar nÃºmeros de telefone
function formatPhoneNumber(phone) {
    if (!phone) return '';
    return phone.replace(/(\d{2})(\d{2})(\d{5})(\d{4})/, '+$1 ($2) $3-$4');
}

// Inicializar quando o documento estiver pronto
document.addEventListener('DOMContentLoaded', function() {
    setupSessionStatusPolling();
});

// Handler global para o modal de QR Code
document.body.addEventListener('htmx:afterSwap', function(evt) {
    if (evt.detail.target.id === 'qrcodeModal') {
        document.getElementById('qrcodeModal').classList.remove('hidden');
    }
});

// FunÃ§Ã£o para fechar o modal
function closeModal() {
    document.getElementById('qrcodeModal').classList.add('hidden');
}
```

## 8. InstruÃ§Ãµes para ExecuÃ§Ã£o e Testes ðŸŸ¡

### 8.1 ExecuÃ§Ã£o do Projeto
```bash
# Navegar atÃ© a pasta do projeto
cd whatsapp-panel

# Executar o projeto
go run cmd/server/main.go
```

### 8.2 Acesso ao Painel
ApÃ³s iniciar o servidor, acesse o painel em:
```
http://localhost:8080
```

### 8.3 Funcionalidades a Testar
1. Conectar um WhatsApp escaneando o QR Code
2. Verificar se o card da sessÃ£o aparece corretamente apÃ³s a conexÃ£o
3. Verificar se as estatÃ­sticas (contatos, grupos, conversas) sÃ£o atualizadas
4. Testar a desconexÃ£o de uma sessÃ£o

## 9. PrÃ³ximos Passos e Melhorias Futuras ðŸ”´

### 9.1 Melhorias de SeguranÃ§a
- Implementar autenticaÃ§Ã£o de usuÃ¡rios
- Adicionar HTTPS/SSL
- Proteger rotas sensÃ­veis

### 9.2 Melhorias de Funcionalidades
- Adicionar suporte para envio de mensagens
- Implementar visualizaÃ§Ã£o de conversas recentes
- Adicionar notificaÃ§Ãµes de novas mensagens
- Criar painel de estatÃ­sticas mais detalhado

### 9.3 Melhorias de Interface
- Adicionar tema escuro
- Criar visualizaÃ§Ã£o em lista e grade para as sessÃµes
- Implementar filtros de busca para conversas
- Adicionar suporte para mÃºltiplos idiomas

### 9.4 Melhorias de Infraestrutura
- Migrar para um banco de dados mais robusto (PostgreSQL/MySQL)
- Implementar sistema de logs mais avanÃ§ado
- Adicionar suporte para containerizaÃ§Ã£o (Docker)
- Configurar CI/CD para deploy automÃ¡tico